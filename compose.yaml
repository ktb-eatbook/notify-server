# networks:
#   proxy:
#     driver: bridge

# services:
#   proxy:
#     container_name: notify-proxy
#     image: nginx
#     restart: always
#     # 서버 컨테이너에도 추가 필요
#     healthcheck:
#       test: ["CMD", "curl", "-f", "http://localhost:80/nginx_status"]
#       interval: 10s
#       timeout: 5s
#       retries: 3
#     ports:
#       - "80:80/tcp"
#       - "443:443"
#     volumes:
#       - ./nestjs.conf:/etc/nginx/conf.d/default.conf
#       - ./nginx.conf:/etc/nginx/nginx.conf
#     networks:
#       - proxy
#     environment:
#       - TZ=Asia/Seoul
#     depends_on:
#       - server
#   server:
#     build: .
#     # image: ${DOCKER_HUB_REPO}/eatbook-notify:deploy
#     deploy:
#       replicas: 3
#     expose:
#       - "3001"
#       - "6379"
#     environment:
#       - SERVER_PORT=${SERVER_PORT}
#     entrypoint: ["sh", "-c"]
#     # DB 컨테이너가 완전히 로드되기 이전에 명령어가 실행되면
#     # DB 동기화와 시드데이터를 넣을 수 없으므로 일정 시간 멈춤
#     # 맨 마지막 구문은 없는 파읽을 읽게해 강제로 컨테이너가 종료되지 않게 함
#         # service redis-server start
#         # sleep 5
#         # npm run start:prod
#     command: 
#       - |
#         redis-server --port 6379 & 
#         sleep 5 && 
#         npm run start:prod &&
#         tail -f /dev/null
#     networks:
#       - proxy

services:
  server:
    container_name: notify-server
    image: ${DOCKER_HUB_REPO}/eatbook-notify:deploy
    ports:
      - 3001:3001
      - 6379:6379
    environment:
      - SERVER_PORT=${SERVER_PORT}
    entrypoint: ["sh", "-c"]
    # DB 컨테이너가 완전히 로드되기 이전에 명령어가 실행되면
    # DB 동기화와 시드데이터를 넣을 수 없으므로 일정 시간 멈춤
    # 맨 마지막 구문은 없는 파읽을 읽게해 강제로 컨테이너가 종료되지 않게 함
        # service redis-server start
        # sleep 5
        # npm run start:prod
        # redis-server --port 6379 & 
    command: 
      - |
        sleep 5 && 
        npm run start:prod &&
        tail -f /dev/null